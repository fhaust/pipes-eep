{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Proxy
import Control.Proxy.Concurrent

import Control.Monad

import Control.Concurrent.Async

import Pipes.CEP

import qualified Data.Map as M

import qualified Data.Text as T


import Data.List
import Data.Maybe


import Test.QuickCheck
import Criterion
import Criterion.Main

import MarketData

tickers :: [T.Text]
tickers = map mkTicker [0..999]

--------------------------------------------------


broadcastD :: Proxy p => [Input a] -> () -> Pipe p a a IO () 
broadcastD = foldr ((>->) . sendD) pull 


--sendSwitchD :: (Ord k, Proxy p) => (b -> k) -> [(k, Input b)] -> () -> p () b b' b IO () 
--sendSwitchD predicate sm () = runIdentityP loop 
--  where sm' = M.fromList sm
--        loop = do 
--          -- request the next value
--          v <- request ()

--          -- lookup receiver in our map
--          let input = M.lookup (predicate v) sm'

--          -- send value only if receiver was found
--          success <- case input of
--            (Just i) -> lift . atomically $ send i v
--            Nothing  -> return True  
          
--          -- when we send sucessfully
--          -- we respond and loop
--          when success $ do
--            _ <- respond v
--            loop


sendSwitchD :: (Ord k, Proxy p) => (b -> k) -> [(k, Input b)] -> () -> Consumer p b IO () 
sendSwitchD predicate sm () = runIdentityP loop 
  where sm' = M.fromList sm
        loop = do 
          -- request the next value
          v <- request ()

          -- lookup receiver in our map
          let i = M.lookup (predicate v) sm'

          -- send value only if receiver was found
          when (isJust i) $ lift . atomically . void $ send (fromJust i) v


--------------------------------------------------

main :: IO ()
main = do

  --let ss = force $ map statement1 tickers 

  -- create test data
  -- this is randomly generated by quickcheck ... so it may effect the results
  -- but I am lazy and don't want to create data by hand
  td <- fmap concat $ replicateM 100 (sample' arbitrary  :: IO [MarketData])

  -- force the creation of the list by showing the length
  -- note: this of course won't evaluate the individual values
  --       but it doesn't make a big difference in the end
  print $ "done forcing " ++ show (length td) ++ " elements"
  

  -- function to calculate the average price
  let avg e = sum e / genericLength e 

  -- some simple tests to get running 
  let s1 = bench "only fromListS" $ nfIO $ runProxy $ fromListS td
  let s2 = bench "mapD price >-> windowTime 10 >-> mapD sum" $ nfIO $ runProxy $ 
             fromListS td >-> mapD price >-> windowTime 10 >-> mapD avg 
  let s3 = bench "mapD price >-> windowLength 10 >-> mapD sum" $ nfIO $ runProxy $ 
             fromListS td >-> mapD price >-> windowLength 10 >-> mapD avg 


  -- filter tests
  let s4 = bench "filterD (\\e -> ticker e == \"S0AAA\") >-> windowLength 10 >-> mapD (sum . map price)" 
            $ nfIO $ runProxy $ 
             fromListS td >-> filterD (\e -> ticker e == "S0AAA") 
                          >-> mapD price
                          >-> windowLength 10 
                          >-> mapD avg 


  -- switch test
  let s5 = bench "test sendSwitch" $ nfIO 
         $ do 
            -- create mailboxes
            (ins, outs) <- fmap unzip $ replicateM (length tickers) $ spawn Unbounded

            -- create statements
            let stmt o = recvS o >-> mapD price
                                 >-> windowLength 10 
                                 >-> mapD avg

            let stmts = map stmt outs 

            -- spark statements
            asyncs <- forM stmts $ \s -> async (runProxy s >> performGC)

            -- run the actual proxy
            runProxy $ fromListS td >-> sendSwitchD ticker (zip tickers ins)

            -- wait for other threads to finish
            mapM wait asyncs
    

              


  -- run the benchmarks
  defaultMain [s1, s2, s3, s4, s5]
  





--switch m = do


--   v <- request ()

--  let t = ticker v

--  let stmt = M.findWithDefault pull t m

--  stmt ()
